#!/usr/bin/env php
<?php

/**
 * Hyperf Watch Hot Reload Scripts
 * From: https://github.com/ha-ni-cc/hyperf-watch
 * Author: hanicc@qq.com
 * Fork & Modify From: https://github.com/leocavalcante/dwoole/blob/master/dev/watch.php
 * Usage:
 * Open the terminal console in the project root directory and enterï¼šphp watch
 * åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰“å¼€ç»ˆç«¯æŽ§åˆ¶å°ï¼Œè¾“å…¥ï¼šphp watch
 * If you want to clean the /runtime/container cache, enter: php watch -c
 * å¦‚æžœä½ æƒ³è¦æ¸…é™¤/runtime/containerç¼“å­˜ï¼Œåˆ™è¾“å…¥ï¼šphp watch -c
 */

# PHP Bin File PHPç¨‹åºæ‰€åœ¨è·¯å¾„ï¼ˆé»˜è®¤è‡ªåŠ¨èŽ·å–ï¼‰
const PHP_BIN_FILE = 'which php';
# Watch Dir ç›‘å¬ç›®å½•ï¼ˆé»˜è®¤ç›‘å¬è„šæœ¬æ‰€åœ¨çš„æ ¹ç›®å½•ï¼‰
const WATCH_DIR = __DIR__ . '/';
# Watch Ext ç›‘å¬æ‰©å±•åï¼ˆå¤šä¸ªå¯ç”¨è‹±æ–‡é€—å·éš”å¼€ï¼‰
const WATCH_EXT = 'php,env';
# Exclude Dir æŽ’é™¤ç›®å½•ï¼ˆä¸ç›‘å¬çš„ç›®å½•ï¼Œæ•°ç»„å½¢å¼)
const EXCLUDE_DIR = ['vendor'];
# Entry Point File å…¥å£æ–‡ä»¶
const ENTRY_POINT_FILE = './bin/hyperf.php';
# Start Command å¯åŠ¨å‘½ä»¤
const START_COMMAND = [ENTRY_POINT_FILE, 'start'];
# PID File Path PIDæ–‡ä»¶è·¯å¾„
const PID_FILE_PATH = './runtime/hyperf.pid';
# Scan Interval æ‰«æé—´éš”ï¼ˆæ¯«ç§’ï¼Œé»˜è®¤2000ï¼‰
const SCAN_INTERVAL = 2000;

if (!function_exists('exec')) {
    echo '[x] è¯·åœ¨php.inié…ç½®ä¸­å–æ¶ˆç¦ç”¨execæ–¹æ³•' . PHP_EOL;
    exit(1);
}

define('PHP', PHP_BIN_FILE == 'which php' ? @exec('which php') : PHP_BIN_FILE);

if (!file_exists(PHP) || !is_executable(PHP)) {
    echo '[x] PHP bin (" ' . PHP . ' ") è·¯å¾„æ²¡æœ‰æ‰¾åˆ°æˆ–æ— æ³•æ‰§è¡Œï¼Œè¯·ç¡®è®¤è·¯å¾„æ­£ç¡®?' . PHP_EOL;
    exit(1);
}

if (!file_exists(ENTRY_POINT_FILE)) {
    echo '[x] å…¥å£æ–‡ä»¶ ("' . ENTRY_POINT_FILE . '") æ²¡æœ‰æ‰¾åˆ°ï¼Œè¯·ç¡®è®¤æ–‡ä»¶å­˜åœ¨?' . PHP_EOL;
    exit(1);
}

// å¦‚æžœå®‰è£…äº†pcntlæ‰©å±•ï¼ˆä¸ºäº†è§£å†³åœ¨PHPStormä½¿ç”¨äº†WSLä¸­çš„PHPæ‰§è¡Œå™¨åˆ›å»ºçš„PHP Scriptåœ¨åœæ­¢æˆ–é‡å¯ç›‘å¬è„šæœ¬æ— æ³•é€€å‡ºæ—§è¿›ç¨‹ï¼Œä»Žè€Œå¯¼è‡´çš„ä¸€äº›â€œç¾éš¾â€ï¼‰
if (extension_loaded('pcntl')) {
    //ç›‘å¬è„šæœ¬å¼€å¯ä¿¡å·å¤„ç†
    pcntl_async_signals(true);
    function sigHandler($signo)
    {
        if (in_array($signo, [SIGHUP, SIGINT, SIGKILL, SIGTERM])) {
            echo PHP_EOL . "ðŸ˜Š Exit the watching process successfully @ " . date('Y-m-d H:i:s') . PHP_EOL;
            killOldProcess();
        }
        exit(9);
    }
    // æ³¨å†Œä¿¡å·å¤„ç†å™¨
    pcntl_signal(SIGHUP, 'sigHandler');
    pcntl_signal(SIGINT, 'sigHandler');
    pcntl_signal(SIGTERM, 'sigHandler');
} else echo "â—ï¸Warning: The pcntl extension is recommended." . PHP_EOL;

use Swoole\Process;
use Swoole\Timer;
use Swoole\Event;

swoole_async_set(['enable_coroutine' => false]);
$hashes = [];
$serve = null;
echo "ðŸš€ Start @ " . date('Y-m-d H:i:s') . PHP_EOL;
start();
state();
Timer::tick(SCAN_INTERVAL, 'watch');

function killOldProcess()
{
    // pidå­˜åœ¨åˆ™å…³é—­å­˜åœ¨çš„è¿›ç¨‹
    if (file_exists(PID_FILE_PATH) && $pid = @file_get_contents(PID_FILE_PATH)) {
        @posix_kill($pid, SIGKILL);
    } else {
        // æ‰¾ä¸åˆ°pidï¼Œå¼ºæ€.Masterè¿›ç¨‹ï¼ˆä¸å¤Ÿä¼˜é›…ï¼Œå¯èƒ½ä¼šè¯¯æ€å…¶å®ƒè¿›ç¨‹åä¹Ÿä¸º.Masterçš„è¿›ç¨‹ï¼ŒT_Tï¼‰
        @exec("ps -ef | grep .Master | grep -v grep |awk '{print $2}'| xargs kill -9");
    }
}

function start()
{
    // æ€æ—§è¿›ç¨‹
    killOldProcess();
    global $serve;
    $serve = new Process('serve', true);
    $serve->start();
    if (false === $serve->pid) {
        echo swoole_strerror(swoole_errno()) . PHP_EOL;
        exit(1);
    }
    Event::add($serve->pipe, function ($pipe) use (&$serve) {
        $message = @$serve->read();
        if (!empty($message)) {
            echo $message;
        }
    });
}

function watch()
{
    global $hashes;
    foreach ($hashes as $pathName => $currentHash) {
        if (!file_exists($pathName)) {
            unset($hashes[$pathName]);
            continue;
        }
        $newHash = fileHash($pathName);
        if ($newHash != $currentHash) {
            change();
            state();
            break;
        }
    }
}

function state()
{
    global $hashes;
    $files = phpFiles(WATCH_DIR);
    $hashes = array_combine($files, array_map('fileHash', $files));
    $count = count($hashes);
    echo "ðŸ“¡ Watching $count files..." . PHP_EOL;
}

function change()
{
    global $serve;
    echo "ðŸ”„ Restart @ " . date('Y-m-d H:i:s') . PHP_EOL;
    Process::kill($serve->pid);
    start();
}

function serve(Process $serve)
{
    $opt = getopt('c');
    # if (isset($opt['c'])) echo exec(PHP . ' ' . ENTRY_POINT_FILE . ' di:init-proxy') . '..' . PHP_EOL;
    if (isset($opt['c'])) delDir('./runtime/container');
    $serve->exec(PHP, START_COMMAND);
}

function fileHash(string $pathname): string
{
    $contents = file_get_contents($pathname);
    if (false === $contents) {
        return 'deleted';
    }
    return md5($contents);
}

function phpFiles(string $dirname): array
{
    $directory = new RecursiveDirectoryIterator($dirname);
    $filter = new Filter($directory);
    $iterator = new RecursiveIteratorIterator($filter);
    return array_map(function ($fileInfo) {
        return $fileInfo->getPathname();
    }, iterator_to_array($iterator));
}

function delDir($path)
{
    if (is_dir($path)) {
        //æ‰«æä¸€ä¸ªç›®å½•å†…çš„æ‰€æœ‰ç›®å½•å’Œæ–‡ä»¶å¹¶è¿”å›žæ•°ç»„
        $dirs = scandir($path);
        foreach ($dirs as $dir) {
            //æŽ’é™¤ç›®å½•ä¸­çš„å½“å‰ç›®å½•(.)å’Œä¸Šä¸€çº§ç›®å½•(..)
            if ($dir != '.' && $dir != '..') {
                //å¦‚æžœæ˜¯ç›®å½•åˆ™é€’å½’å­ç›®å½•ï¼Œç»§ç»­æ“ä½œ
                $sonDir = $path . '/' . $dir;
                if (is_dir($sonDir)) {
                    //é€’å½’åˆ é™¤
                    delDir($sonDir);
                    //ç›®å½•å†…çš„å­ç›®å½•å’Œæ–‡ä»¶åˆ é™¤åŽåˆ é™¤ç©ºç›®å½•
                    @rmdir($sonDir);
                } else {
                    //å¦‚æžœæ˜¯æ–‡ä»¶ç›´æŽ¥åˆ é™¤
                    @unlink($sonDir);
                }
            }
        }
        @rmdir($path);
    }
}

class Filter extends RecursiveFilterIterator
{
    public function accept()
    {
        if ($this->current()->isDir()) {
            if (preg_match('/^\./', $this->current()->getFilename())) {
                return false;
            }
            return !in_array($this->current()->getFilename(), EXCLUDE_DIR);
        }
        $list = array_map(function (string $item): string {
            return "\.$item";
        }, explode(',', WATCH_EXT));
        $list = implode('|', $list);
        return preg_match("/($list)$/", $this->current()->getFilename());
    }
}
